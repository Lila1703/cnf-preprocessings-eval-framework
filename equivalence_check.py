from os import path, remove
from shlex import split
from subprocess import check_output, STDOUT, TimeoutExpired, CalledProcessError


def _read_dimacs_clauses(file_path):
    max_var = 0
    clauses = []
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('c'):
                continue
            if line.startswith('p'):
                parts = line.split()
                if len(parts) >= 4:
                    try:
                        max_var = int(parts[2])
                    except Exception:
                        pass
                continue
            lits = [int(x) for x in line.split() if x != '0']
            if lits:
                clauses.append(lits)
                for l in lits:
                    if abs(l) > max_var:
                        max_var = abs(l)
    return max_var, clauses


def build_diff_cnf(f_path, g_path, out_path, mode='F_and_not_G'):
    """Build a CNF file that is satisfiable if:
    - mode == 'F_and_not_G': there exists assignment with F true and G false
    - mode == 'G_and_not_F': there exists assignment with G true and F false

    The construction introduces fresh variables z_j for clauses of the formula
    being negated, links them to their clauses, and then forces that at least
    one z_j is false (meaning that clause is false) while the other formula
    holds.
    """
    if mode == 'F_and_not_G':
        F_path, G_path = f_path, g_path
    else:
        F_path, G_path = g_path, f_path

    max_var, F_clauses = _read_dimacs_clauses(F_path)
    max_var_g, G_clauses = _read_dimacs_clauses(G_path)
    max_var = max(max_var, max_var_g)

    # We'll introduce one fresh var per clause in G_clauses
    z_start = max_var + 1
    z_vars = [z_start + i for i in range(len(G_clauses))]

    out_clauses = []

    # Add clauses from F unchanged
    for c in F_clauses:
        out_clauses.append(list(c))

    # For each clause C_j in G, create z_j <-> (disjunction of literals in C_j)
    # Encode: (¬z_j ∨ l1 ∨ ... ∨ lk) and for each li: (¬li ∨ z_j)
    for (j, clause) in enumerate(G_clauses):
        z = z_vars[j]
        # (¬z ∨ l1 ∨ ...)
        out_clauses.append([-z] + list(clause))
        # for each literal li: (¬li ∨ z)
        for li in clause:
            out_clauses.append([-li, z])

    # Add clause enforcing that at least one z_j is false -> (¬z1 ∨ ¬z2 ∨ ...)
    if z_vars:
        out_clauses.append([-z for z in z_vars])

    total_vars = z_start + len(z_vars) - 1
    total_clauses = len(out_clauses)

    with open(out_path, 'w') as out:
        out.write(f"c generated by equivalence check\n")
        out.write(f"p cnf {total_vars} {total_clauses}\n")
        for c in out_clauses:
            out.write(' '.join(str(x) for x in c) + ' 0\n')


def run_sat_solver(solver_template, cnf_path, timeout=None):
    """Run a SAT solver command template (containing '{input}') on `cnf_path`.
    Returns True for SAT, False for UNSAT, None for timeout or unknown output."""
    command = solver_template.format(input=cnf_path)
    try:
        args = split(command)
        output = check_output(args, stderr=STDOUT, timeout=timeout)
        text = output.decode('utf-8', errors='ignore')
    except CalledProcessError as e:
        text = e.output.decode('utf-8', errors='ignore') if e.output else ''
    except TimeoutExpired:
        return None

    up = text.upper()
    if 'UNSAT' in up:
        return False
    if 'SAT' in up:
        return True
    return None
